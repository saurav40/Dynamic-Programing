                                       Knapsack
                                    |       |        | 
                                  |         |            |
                             Fractional   Knapsack(0/1)   Unbounded Knapsack  
                             Knapsack
         
    Unbounded Knapsack-Repetition of elment is allowed
    
    The Only difference is we can include an element multiple time in unbounded.
    And if we exclude an element we can't repeat that element:
    
    for example
    let these are the element of knapsack
    
    a1 a2 a3 a4 a5
                if we exclude a5 then we have made a decision that we are done we a5.
                But if We include it we may or may not include this elment again.
   //Recursive 
   
   if(n==0 || W==0)
       return 0;
   int choice1=-1;
   if(wt[n-1]<=W)
   {
       choice1=Math.max(val[n-1]+Knapsack(n,W-Wt[n-1],val,wt),Knapsack(n-1,W,val,wt);
   }
   return Math.max(choice1,Knapsack(n-1,W,val,wt));
   
   //Memoization
   
   t[n+1][W+1]:
           -1 -1 -1
           -1 -1 -1 
           -1 -1 -1
      
   if(n==0 || W==0)
       return 0;
   if(t[n][W]!=-1)
      return t[n][W];
  
   if(wt[n-1]<=W)
   {
       t[n][W]=Math.max(val[n-1]+Knapsack(n,W-Wt[n-1],val,wt),Knapsack(n-1,W,val,wt);
   }
   return t[n][W]=Math.max(t[n][W],Knapsack(n-1,W,val,wt));
  
  //Bottom-Up
  static int knapSack(int N, int W, int val[], int wt[])
    {
        int t[][]=new int[N+1][W+1];
        
        for(int i=1;i<=N;i++)
          for(int j=1;j<=W;j++)
          {
              if(wt[i-1]<=j)
              {
                  t[i][j]=Math.max(val[i-1]+t[i][j-wt[i-1]],t[i-1][j]);
              }
              else
              {
                  t[i][j]=t[i-1][j];
              }
          }
          return t[N][W];
    }
           
---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------

Related problems
----------------
1.Rod cutting
2.Coin Change
3.Coin Change II
4.Maximum Ribbon cut
----------------------------
1.Rod Cutting

Given a rod of length n inches and an array of prices that includes prices of all pieces of size smaller than n. 
Determine the maximum value obtainable by cutting up the rod and selling the pieces. 

Input:length 1  2  3  4   5   6   7  8 
      Price={1, 5, 8, 9, 10, 17, 17, 20} 
      maX_Length=size(arr)=8
      
      if max_length=0 return 0;
      if(n==0) return 0;
      
      int RodCutting(int[] price,int[] length,int MaxLength,int n)
      {
          if(n==0 || MaxLength)
             return 0;
          if(t[n][MaxLength]!=-1)
             return t[n][MaxLength];
          if(length[n-1]<=MaxLength)
          {
               t[n][MaxLength]=Math.max(price[n-1]+RodCutting(price,length,MaxLength-length[n-1],n),RodCutting(price,length,MaxLength,n-1);
           }
           return Math.max(t[n][MaxLength],RodCutting(price,length,MaxLength,n-1));
      }
      
